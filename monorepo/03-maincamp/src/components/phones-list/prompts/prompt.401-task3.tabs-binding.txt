# 프롬프트 401 - Task3: 상태 탭 네비게이션 (데이터 바인딩)

**타입**: Data Binding
**컴포넌트**: phones-list-tabs
**목표**: "판매중인 기기" / "거래완료 기기" 탭 필터링 상태 관리 및 바인딩

==================================================

## 조건

### Cursor Rules
@01-common.mdc
@04-func.mdc

### 파일 경로
- 훅: `src/components/phones-list/hooks/use-tabs-filter.hook.ts` (없다면 생성)
- TSX: `src/components/phones-list/index.tabs.tsx`

### 상태 관리 가이드
- `activeTab`, `setActiveTab`, `allCards` 등은 `src/components/phones-list/stores/use-phone-list.store.ts` (또는 동등한 Context 스토어)에 보관한다. 파일이 없으면 이번 작업에서 생성한다.
- Supabase 연동 전까지는 `samplePhones` 데이터를 스토어 초기값으로 넣고, 필요 시 이후 API 연동 시 같은 인터페이스를 유지한다.

### 데이터 구조
```typescript
type TabStatus = "selling" | "sold";

interface TabItem {
  id: TabStatus;
  label: string;              // "판매중인 기기", "거래완료 기기"
  count?: number;             // 각 탭별 아이템 개수
}

interface TabsState {
  activeTab: TabStatus;
  tabs: TabItem[];
  filteredCards: PhoneCardItem[];  // 필터링된 카드 배열
}
```

### Zustand 스토어 연동
```typescript
// phoneListStore에 다음 상태 추가
// - activeTab: "selling" | "sold"
// - setActiveTab: (tab: TabStatus) => void
// - filteredCards: PhoneCardItem[]
```

### Supabase 데이터
```typescript
// Supabase phones 테이블
// SELECT * FROM phones WHERE status = 'selling' OR status = 'sold'
```

==================================================

## 핵심요구사항

핵심요구사항) playwright 테스트를 활용하여 TDD 기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.

1) 테스트 제외 라이브러리
   - jest
   - @testing-library/react

2) 테스트 조건
   - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
   - 페이지가 완전히 로드된 후 테스트할 것.
       - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
       - **중요금지사항** 페이지 로드 식별 금지사항: networkidle 대기 방법
   - Playwright 환경이 준비되지 않았다면 `03-maincamp` 패키지에 `playwright.config.ts`를 생성하고 `@playwright/test` 설치 및 `package.json` 스크립트를 추가한 뒤 실행한다.

---

1) 탭 필터 훅 구현
   1-1) useTabsFilter() 훅 생성
        - Zustand 스토어에서 activeTab, setActiveTab 구독
        - filteredCards 계산
   1-2) 초기값: activeTab = "selling"
   1-3) Supabase에서 데이터 조회
        - SELECT * FROM phones WHERE status = activeTab
        - 또는 로컬 샘플 데이터 필터링

2) 탭 UI 렌더링
   2-1) Tab 컴포넌트 생성 (또는 기존 @commons/ui 활용)
   2-2) Props: { label, isActive, onClick }
   2-3) 활성 탭 스타일
        - 배경: 검은색 (#1c1c1c)
        - 텍스트: 흰색
        - 폰트: 16px, 600 weight (SemiBold)
   2-4) 비활성 탭 스타일
        - 배경: 흰색 또는 투명
        - 텍스트: 회색 (#666666)
        - 폰트: 16px, 500 weight (Medium)

3) 탭 클릭 핸들러
   3-1) handleTabChange(tabStatus: TabStatus)
        - setActiveTab(tabStatus) 호출
        - Zustand 스토어 업데이트
   3-2) data-testid="tab-{tabStatus}" 속성 추가
   3-3) onClick={() => handleTabChange(tabStatus)}

4) 카드 필터링 로직
   4-1) activeTab 변경 시 카드 데이터 필터링
   4-2) filteredCards = allCards.filter(card => card.status === activeTab)
   4-3) 또는 Supabase에서 쿼리 필터링
        - SELECT * FROM phones WHERE status = activeTab
   4-4) 결과: 새로운 카드 배열로 그리드 업데이트

5) 탭별 아이템 개수 표시 (선택사항)
   5-1) 각 탭 라벨 옆에 개수 표시: "(10개)"
   5-2) 또는 배지로 표시: "판매중인 기기 10"

6) 테스트 케이스 작성
   6-1) 파일: `src/components/phones-list/tests/tabs-filter.spec.ts`
   6-2) 테스트 1: "판매중인 기기" 탭 클릭 시 카드 필터링
        - 조건: 탭 UI 렌더링됨
        - 실행: "판매중인 기기" 탭 클릭
        - 검증: 카드 그리드에 selling 상태의 카드만 표시됨
   6-3) 테스트 2: "거래완료 기기" 탭 클릭 시 카드 필터링
        - 조건: 탭 UI 렌더링됨
        - 실행: "거래완료 기기" 탭 클릭
        - 검증: 카드 그리드에 sold 상태의 카드만 표시됨
   6-4) 테스트 3: 탭 활성 상태 시각적 피드백
        - 조건: 두 탭 모두 렌더링됨
        - 실행: 탭 클릭
        - 검증: 클릭한 탭 배경색이 검은색, 텍스트는 흰색
   6-5) 테스트 4: 페이지 로드 시 기본 탭 = "판매중인 기기"
        - 조건: 페이지 로드됨
        - 실행: 없음 (자동)
        - 검증: "판매중인 기기" 탭이 활성화되고 카드 표시

7) Props & Types
```typescript
interface UseTabsFilterReturn {
  activeTab: TabStatus;
  setActiveTab: (tab: TabStatus) => void;
  filteredCards: PhoneCardItem[];
  tabs: TabItem[];
}

interface TabProps {
  label: string;
  isActive: boolean;
  onClick: () => void;
  count?: number;
}

interface TabsContainerProps {
  className?: string;
  onTabChange?: (tab: TabStatus) => void;
}
```

8) 구현 예시 구조
```typescript
// hook
export const useTabsFilter = () => {
  const activeTab = usePhoneListStore(state => state.activeTab);
  const setActiveTab = usePhoneListStore(state => state.setActiveTab);
  const allCards = usePhoneListStore(state => state.allCards);

  const filteredCards = useMemo(
    () => allCards.filter(card => card.status === activeTab),
    [activeTab, allCards]
  );

  const tabs: TabItem[] = [
    { id: 'selling', label: '판매중인 기기', count: filteredCards.filter(c => c.status === 'selling').length },
    { id: 'sold', label: '거래완료 기기', count: filteredCards.filter(c => c.status === 'sold').length }
  ];

  return { activeTab, setActiveTab, filteredCards, tabs };
};

// component
export const TabsContainer = () => {
  const { activeTab, setActiveTab, tabs } = useTabsFilter();

  return (
    <div className={styles.tabsContainer}>
      {tabs.map(tab => (
        <Tab
          key={tab.id}
          data-testid={`tab-${tab.id}`}
          label={tab.label}
          isActive={activeTab === tab.id}
          onClick={() => setActiveTab(tab.id)}
          count={tab.count}
        />
      ))}
    </div>
  );
};
```

9) 추가 고려사항
   9-1) URL 동기화: Task14 참고 (?status=selling)
   9-2) 로컬스토리지: 마지막 선택 탭 저장 (선택)
   9-3) 캐싱: Zustand store에서 카드 데이터 캐싱

==================================================
