아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 구현될 HOOK 파일경로: src/components/inquiries/hooks/index.reply-binding.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/inquiries/tests/index.reply-binding.spec.ts

==============================================

조건-스키마) 참고할 Supabase 스키마 문서: /Users/gharam12/Desktop/my-homework/14th_homework/monorepo/03-maincamp/sql/supabase.txt
조건-스키마) 사용할 테이블: phone_inquiries
조건-스키마) 주요 필드
            - id: 문의 UUID PK
            - phone_id: 대상 기기 ID
            - parent_id: 부모 문의 ID (중첩 답변용, NULL이면 최상위 문의)
            - thread_path: 트리 정렬용 경로 문자열
            - author_id: 작성자 ID (auth.users.id)
            - content: 문의 내용 (100자 제한)
            - is_answer: 판매자 답변 여부 (boolean)
            - status: 상태 (active/edited/deleted)
            - created_at: 생성 시각
            - updated_at: 수정 시각

==============================================

핵심요구사항) playwright 테스트를 활용하여 TDD 기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.

1) 테스트 제외 라이브러리
   - jest
   - @testing-library/react

2) 테스트 조건
   - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
   - 페이지가 완전히 로드된 후 테스트할 것.
       - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
       - **중요금지사항** 페이지 로드 식별 금지사항: networkidle 대기 방법

3) 테스트 API 조건
3-1) 데이터
    - 실제 Supabase 데이터를 사용할 것.
    - Mock 데이터를 사용하지 말 것.

3-2) 성공 시나리오
    - Supabase phone_inquiries 테이블에서 답변 데이터 조회 성공
    - parent_id 기반 트리 구조 데이터 정렬 성공
    - thread_path 기준 정렬 성공

3-3) 실패 시나리오
    - API 호출 실패 또는 빈 배열 처리
    - 에러 상태 표시

4) 데이터 조건
    - 저장소: Supabase (phone_inquiries 테이블)
    - 요청방식: Supabase Client select()
    - 요청 파라미터 구조:
        ```typescript
        supabase
          .from('phone_inquiries')
          .select('*')
          .eq('phone_id', phoneId)
          .order('thread_path', { ascending: true })
        ```

핵심요구사항) Supabase 연동 훅을 다음과 같이 구현할 것.
                1) useReplyBinding 훅 생성
                    - 입력: phoneId (상품 ID)
                    - 출력: { data, loading, error, refetch }

                2) 데이터 조회 로직
                    - phone_inquiries 테이블에서 해당 phoneId의 모든 문의/답변 조회
                    - parent_id가 NULL인 항목: 최상위 문의
                    - parent_id가 있는 항목: 답변 (중첩 답변 포함)
                    - thread_path 기준 오름차순 정렬 (트리 구조 유지)

                3) 데이터 변환 로직
                    - Supabase 응답을 InquiryItem[] 타입으로 변환
                    - 필드 매핑:
                        - id: inquiry.id
                        - parentId: inquiry.parent_id
                        - content: inquiry.content
                        - createdAt: inquiry.created_at (YYYY.MM.DD 형식으로 변환)
                        - author: { id, name, avatar } (author_id 기반 사용자 정보 조회 필요)
                        - canEdit: 본인이 작성한 답변인지 확인
                        - canDelete: 본인이 작성한 답변인지 확인

                4) 실시간 업데이트 지원 (선택 사항)
                    - Supabase Realtime을 활용한 자동 갱신
                    - 새 답변 추가 시 자동 리로드

핵심요구사항) 현재의 컴포넌트 구조를 그대로 유지하고, Mock 데이터를 제거하고, 실제 Supabase phone_inquiries 데이터를 바인딩할 것.

1) 바인딩할 데이터
   - useReplyBinding(phoneId) 훅의 결과

2) 데이터 바인딩 상세내용
   - inquiries prop: useReplyBinding의 data 배열
   - 로딩 상태: loading이 true일 때 로딩 표시
   - 에러 상태: error가 있을 때 에러 메시지 표시
   - 빈 데이터: data.length === 0일 때 "문의가 없습니다." 표시

3) 트리 구조 렌더링 조건
   - parent_id가 NULL인 항목만 최상위로 렌더링
   - 각 최상위 문의의 자식 답변은 재귀적으로 렌더링
   - thread_path 순서대로 표시하여 트리 구조 유지

4) 사용자 정보 조회
   - author_id를 기반으로 auth.users 테이블에서 사용자 정보 조회
   - 필드: name (또는 username), avatar (프로필 이미지 URL)
   - 캐싱 전략: 동일한 author_id는 중복 조회 방지

5) 판매자 답변 표시
   - is_answer 필드가 true인 항목: "판매자" 레이블 표시
   - 판매자 프로필 이미지 표시
   - 일반 사용자와 UI 구분

6) CSS 처리
   - 기존 styles.module.css 유지
   - 추가 스타일 없음

7) 테스트
   - 답변 데이터 로드 성공 시나리오
   - 트리 구조 정렬 검증 (thread_path 순서)
   - parent_id 기반 계층 구조 검증
   - 로딩 상태 표시 검증
   - 에러 상태 표시 검증
