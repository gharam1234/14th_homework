아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 구현될 유틸리티 파일경로: src/commons/utils/errorHandler.util.ts
조건-파일경로) 구현될 타입 파일경로: src/commons/utils/errorHandler.types.ts
조건-파일경로) 구현될 TEST 파일경로: src/commons/utils/tests/errorHandler.spec.ts

==============================================

핵심요구사항) playwright 테스트를 활용하여 TDD 기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.

1) 테스트 제외 라이브러리
   - jest
   - @testing-library/react

2) 테스트 조건
   - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
   - 페이지가 완전히 로드된 후 테스트할 것.
       - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
       - **중요금지사항** 페이지 로드 식별 금지사항: networkidle 대기 방법

3) 테스트 시나리오
   3-1) HTTP 상태 코드별 에러 처리
       - 400 (잘못된 요청)
       - 401 (인증 실패)
       - 403 (권한 없음)
       - 404 (리소스 없음)
       - 500 (서버 내부 오류)
       - 502, 503 (서버 일시적 오류)

   3-2) 사용자 친화적 메시지 변환
       - 에러 코드 → 한국어 설명
       - 기술적 메시지 → 이해하기 쉬운 메시지

   3-3) 재시도 가능성 판단
       - 재시도 가능한 에러 (네트워크 오류, 502, 503 등)
       - 재시도 불가능한 에러 (400, 401, 404 등)

==============================================

핵심요구사항) 다음의 서버 에러 공통 핸들러를 step-by-step으로 구현하고, 적용 결과를 체크리스트로 반환할 것.

1) 에러 핸들러 함수 구조
   1-1) handleServerError(error: unknown): HandledError
       - HTTP 상태 코드 추출
       - 에러 코드별 사용자 메시지 반환
       - 재시도 가능 여부 판단
       - 반환 구조:
           - statusCode: number
           - message: string (사용자 친화적 메시지)
           - originalMessage?: string (원본 에러 메시지)
           - isRetryable: boolean (재시도 가능 여부)
           - retryAfter?: number (재시도까지 대기 시간, ms)

   1-2) getErrorMessage(statusCode: number): string
       - HTTP 상태 코드 → 한국어 메시지 매핑
       - 400: "잘못된 요청입니다. 입력 내용을 확인해주세요."
       - 401: "로그인이 필요합니다. 다시 로그인해주세요."
       - 403: "접근 권한이 없습니다."
       - 404: "요청하신 정보를 찾을 수 없습니다."
       - 500: "서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요."
       - 502, 503: "서버가 일시적으로 응답하지 않습니다. 잠시 후 다시 시도해주세요."
       - 기타: "알 수 없는 오류가 발생했습니다."

   1-3) isRetryableError(statusCode: number): boolean
       - 재시도 가능한 에러 판단
       - 재시도 가능: 408 (타임아웃), 429 (과다 요청), 500, 502, 503, 504
       - 재시도 불가능: 400, 401, 403, 404, 422 등

   1-4) getRetryDelay(statusCode: number, retryCount: number): number
       - 재시도 대기 시간 계산 (지수 백오프)
       - 429 (과다 요청): 5000ms (5초)
       - 500번대: 1000ms * (2 ^ retryCount) (1초, 2초, 4초, ...)
       - 최대 대기 시간: 30000ms (30초)

2) 타입 정의 (errorHandler.types.ts)
   2-1) HandledError
       - statusCode: number
       - message: string
       - originalMessage?: string
       - isRetryable: boolean
       - retryAfter?: number

   2-2) ErrorContext (선택적 컨텍스트 정보)
       - endpoint?: string
       - method?: string
       - timestamp: string

3) 에러 로깅 기능 (선택)
   3-1) logError(error: HandledError, context?: ErrorContext): void
       - 콘솔 로깅
       - 에러 발생 시간, 엔드포인트, 메서드 기록

4) 예시 사용법 (테스트 케이스에 포함)
   4-1) API 호출 에러 처리
       try {
           const response = await fetch('/api/data');
           if (!response.ok) {
               throw response;
           }
       } catch (error) {
           const handledError = handleServerError(error);
           console.error(handledError.message);

           if (handledError.isRetryable) {
               setTimeout(() => retryRequest(), handledError.retryAfter);
           } else {
               showErrorToUser(handledError.message);
           }
       }

   4-2) GraphQL 에러 처리
       const { data, error } = await query({ ... });
       if (error) {
           const handledError = handleServerError(error);
           if (!handledError.isRetryable) {
               alert(handledError.message);
           }
       }

==============================================

핵심요구사항) 다음의 제약사항을 준수할 것.
            1) 외부 에러 처리 라이브러리를 사용하지 말 것
            2) 순수 TypeScript로 구현할 것
            3) 모든 에러 메시지는 사용자가 이해하기 쉽게 작성할 것
            4) 에러 핸들러는 동기 함수로 구현할 것 (즉각 반환)
            5) 다양한 에러 타입을 처리할 수 있도록 범용적으로 설계할 것 (fetch, axios, GraphQL 등)
            6) HTTP 상태 코드 외에 네트워크 에러도 처리할 것 (예: TypeError: Failed to fetch)
