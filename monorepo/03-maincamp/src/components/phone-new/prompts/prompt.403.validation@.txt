아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 구현될 유틸리티 파일경로: src/commons/utils/validation.util.ts
조건-파일경로) 구현될 타입 파일경로: src/commons/utils/validation.types.ts
조건-파일경로) 구현될 TEST 파일경로: src/commons/utils/tests/validation.spec.ts

==============================================

핵심요구사항) playwright 테스트를 활용하여 TDD 기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.

1) 테스트 제외 라이브러리
   - jest
   - @testing-library/react

2) 테스트 조건
   - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
   - 페이지가 완전히 로드된 후 테스트할 것.
       - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
       - **중요금지사항** 페이지 로드 식별 금지사항: networkidle 대기 방법

3) 테스트 시나리오
   3-1) 동기 유효성 검사 함수 테스트
       - 필수 필드 검증 (빈값, undefined, null 체크)
       - 가격 형식 검증 (숫자, 음수 금지, 범위)
       - 좌표 값 검증 (latitude: -90~90, longitude: -180~180)
       - 태그 중복 검증
       - 글자 수 제한 검증 (title 최대 100자, description 최대 500자 등)

   3-2) 비동기 유효성 검사 함수 테스트
       - 비동기 검증 함수 실행
       - Promise 기반 검증 결과 반환

   3-3) 병렬 검증 테스트
       - 모든 필드를 한 번에 검증
       - 실패한 필드만 에러 메시지 반환
       - 모든 필드 통과 시 정규화된 데이터 반환

==============================================

핵심요구사항) 다음의 유효성 검사 모듈을 step-by-step으로 구현하고, 적용 결과를 체크리스트로 반환할 것.

1) 유효성 검사 함수 모듈 구조
   1-1) 동기 검사 함수들
       - validateRequired(value: any, fieldName: string): ValidationResult
           - 필수 필드 검증 (빈값, undefined, null)

       - validatePrice(price: number | string, fieldName: string): ValidationResult
           - 숫자 형식 검증
           - 음수 금지
           - 최대/최소 가격 범위 검증 (0 ~ 100,000,000)

       - validateCoordinate(latitude: number, longitude: number): ValidationResult
           - latitude: -90 ~ 90 범위
           - longitude: -180 ~ 180 범위

       - validateTags(tags: string[]): ValidationResult
           - 태그 중복 검증
           - 최대 태그 수 검증 (10개)

       - validateLength(value: string, fieldName: string, max: number, min?: number): ValidationResult
           - 글자 수 최소/최대 길이 검증

   1-2) 비동기 검사 함수들
       - validateAsync(validatorFn: () => Promise<boolean>, errorMessage: string): Promise<ValidationResult>
           - 비동기 검증 함수 래퍼
           - Promise 반환

   1-3) 병렬 검증 함수
       - validateAllFields<T>(data: T, rules: ValidationRules<T>): Promise<ValidationResultSet<T>>
           - 모든 필드를 병렬로 검증 (Promise.all 사용)
           - 실패한 필드의 목록과 에러 메시지 반환
           - 모든 필드 통과 시 정규화된 데이터 반환
           - 정규화 규칙:
               - 문자열: 앞뒤 공백 제거 (trim)
               - 숫자: string → number 형 변환
               - 태그: 문자열 → 배열 변환 및 중복 제거

2) 타입 정의 (validation.types.ts)
   2-1) ValidationResult
       - success: boolean
       - errorMessage?: string
       - value?: any (정규화된 값)

   2-2) ValidationRules<T>
       - 각 필드별 검증 규칙 정의
       - sync: 동기 검증 함수 배열
       - async?: 비동기 검증 함수 배열

   2-3) ValidationResultSet<T>
       - isValid: boolean
       - errors: Record<keyof T, string> (필드별 에러 메시지)
       - normalizedData?: T (정규화된 데이터)

3) 정규화 규칙
   3-1) 문자열
       - 앞뒤 공백 제거 (trim)
       - 빈 문자열 → null 변환 (선택 필드일 경우)

   3-2) 숫자
       - string 타입 → number 형 변환
       - NaN 체크

   3-3) 배열
       - 문자열 → 배열 변환 (쉼표 구분)
       - 중복 제거
       - 빈 배열 처리

4) 예시 사용법 (테스트 케이스에 포함)
   4-1) 단일 필드 검증
       const result = validateRequired(formData.title, 'title');
       if (!result.success) {
           console.error(result.errorMessage);
       }

   4-2) 병렬 검증
       const rules = {
           title: { sync: [validateRequired, (v) => validateLength(v, 'title', 100)] },
           price: { sync: [validateRequired, validatePrice] },
           tags: { sync: [validateTags] },
       };

       const result = await validateAllFields(formData, rules);
       if (!result.isValid) {
           console.error(result.errors);
       } else {
           submitForm(result.normalizedData);
       }

==============================================

핵심요구사항) 다음의 제약사항을 준수할 것.
            1) zod외에 외부 유효성 검증 라이브러리를 사용하지 말 것 (예: yup, joi)
            2) 순수 TypeScript로 구현할 것
            3) 모든 에러 메시지는 한국어로 작성할 것
            4) 정규화 로직은 순수 함수로 구현할 것 (부수 효과 없음)
            5) 모든 검증 함수는 재사용 가능하도록 범용적으로 설계할 것
